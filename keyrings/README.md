# keyrings 本地提权漏洞
1. 本质上是use-after-free漏洞。
1. CVE-2016-0728 这个漏洞本身存在于Linux内核密钥管理和保存功能keyrings中。keyrings主要功能是为驱动程序在内核中保留或者缓存安全数据、身份认证秘钥、加密秘钥以及其他数据。提供系统调用接口——即keyctl系统调用。
1. 每个进程都会使用keyctl为当前的会话创建一个密钥环（keyring）。keyring对象能够通过引用相同keyring名称在不同进程中进行共享。如果进程已经拥有一个会话keyring，keyctl系统调用便会使用新的keyring取代原来的。如果一个对象被多个进程共享，位于usage字段的对象内部引用计数便会递增。当进程替换当前的keyring时，有可能发生泄漏。
1. 存储对象引用计数的数据字段是atomic_t数据类型的，即实际上是int数据类型，意味着在32和64位体系架构上都是32位大小，可以导致该数据溢出——循环2^32次，让usage达到0，此时垃圾回收算法会释放keyring对象。
1. RCU工作机制进行调用来修改keyring（在修改数据的时候，首先需要读取数据，然后生成一个副本，对副本进行修改，修改完成之后再将老数据update成新的数据，此所谓RCU），中间有一个时间差，可以产生不一致的情况，即一个进程指向keyring，但实际上这个keyring因为usage引用为0,被内核已经释放了。
1. keyring内部有一些函数指针，通过覆盖该内存为指定的代码，从而达到执行特定代码的目的。

# 大致做法
1. 保留一个密钥对象的（合法）引用；
2. 溢出相同密钥环（keyring）对象的usage字段；
3. 获取已释放的密钥环（keyring）对象
4. 从用户空间中，使用用户可控的内容在已释放密钥环（keyring）对象所占用的内存空间上分配一个新的内核对象。
5. 使用旧的密钥对象的引用，并触发代码执行

# 参考
1. [freebuf技术贴](http://www.freebuf.com/vuls/93799.html)
